-----

Chapter09. 가상 메모리 관리

-----  
### 01. 요구 페이징
#### 요구 페이징이란?
메모리를 효율적으로 관리하고 응답 속도를 향상시키기 위해서  
메모리에는 꼭 필요한 프로세스만 유지하는 것이 좋음  
프로그램의 일부만 가져와 실행하고 사용자가 특정 기능을 요구할 때  
해당 모듈을 메모리에 올리면 메모리 절약, 효율적 관리, 프로세스의 응답 속도 향상 등의 효과가 있음  
이처럼 사용자가 요구할 때 해당 페이지를 메모리로 가져오는 것을 **요구 페이징** 이라고 함

요구 페이징과 반대의 개념은 **미리 가져오기** 인데  
앞으로 필요할 것이라고 예상되는 페이지를 미리 가져오는 방식으로  
대표적인 경우에 **캐시**가 있음  
현대의 운영체제는 요구페이징을 기본으로 사용  

* 스와핑 :  
  프로세스를 구성하는 모든 페이지를 메모리에 올리는 것  
* 게으른 스와핑 :  
  사용자가 요구할 때 페이지를 메모리에 올리는 것  

#### 페이지 테이블 엔트리의 구조  
사용자의 프로세스는 물리 메모리와 스왑 영역 중 한 곳에 있음  
페이지가 스왑 영역에 있는 경우는 크게 두가지  
요구 페이징으로 인해 처음 부터 물리 메모리에 올라가지 못한 경우 이거나  
메모리가 꽉 차서 스왑 영역으로 옮겨 온 경우  
이 때 페이지 테이블에 페이지가 어디에 있는지 표시할 때 사용하는 것이 **유효 비트**  

페이지 테이블의 한 행을 **페이지 테이블 엔트리** 라고 함  
페이지 번호, 플래그 비트, 프레임 번호로 구성됨  
플래그 비트에는 접근 비트, 변경 비트, 유효 비트, 읽기, 쓰기, 실행 비트 가 있음  

#### 페이지 부재  
프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황  
부재가 발생하면 프로세스가 해당 페이지를 사용할 수 있도록  
스왑 영역에서 물리 메모리로 옮겨야 함  

메모리에 빈 프레임이 있으면 작업이 수월하지만  
빈 프레임이 없는 경우 메모리에 있는 프레임 중 하나를 스압 영역으로 보낸 후  
해당 페이지를 가져올 수 있음
이 때 어떤 페이지를 스왑 영역으로 내보낼지 결정하는 알고리즘을 **페이지 교체 알고리즘** 이라고 하며,  
대상이 되는 페이지는 **대상 페이지** 라고 함  

#### 세그먼테이션 오류 vs 페이지 부재
* 세그먼 테이션 오류 :  
  사용자의 프로세스가 주어진 메모리 공간을 벗어나거나 접근 권한이 없는 곳에 접근할 때 발생  
  사용자 프로세스에 의해 발생  
* 페이지 부재 :  
  해당 페이지가 물리 메모리에 없을 때 발생하는 오류  
  사용자 프로세스와 무관  

### 02. 페이지 교체 알고리즘
#### 페이지 교체 알고리즘  
스왑 영역으로 보낼 페이지를 결정하는 알고리즘으로  
메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정하여  
페이지 부재를 줄이고 시스템의 성능을 향상시킴  

페이지 교체 알고리즘이 쫒아낼 페이지를 찾을 때는 **지역성**을 바탕으로 함  
(공간의 지역성, 시간의 지역성, 순차적 지역성)  

무작위 / FIFO / 최적 / 최적 근접 알고리즘 (LRU, LFU, NUR, FIFO변형, 시계)  

#### 무작위 페이지 교체 알고리즘  
페이지 교체 알고리즘 중 가장 간단하게 구현할 수 있는 방식  
스왑 영역으로 쫒아낼 대상 페이지를 특별한 로직 없이 무작위로 선정  
지역성을 전혀 고려하지 않기 때문에 자주 사용하는 페이지가 대상 페이지로 선정되기도 함  
성능이 좋지 않아 거의 사용되지 않음  

#### FIFO 페이지 교체 알고리즘  
시간상으로 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정하여 스왑 영역으로 쫒아냄  
큐로 구현하며, 메모리의 맨 위에 있는 페이지는 가장 오래된 페이지이고  
맨 아래에 있는 페이지는 새로 들어온 페이지임  
무조건 오래된 페이지를 대상 페이지로 선정하기 때문에 성능이 떨어짐  

#### 최적 페이지 교체 알고리즘  
앞으로 사용하지 않을 페이지를 스왑 영역으로 옮김  
페이지 교체 선정 시점부터 사용 시점까지 가장 멀리 있는 페이지를 대상 페이지로 선정  
메모리 접근 패턴을 보고 대상 페이지를 결정하기 때문에 성능이 좋지 않음  
미래의 데이터를 참고하여 패턴을 예측해야 하는데  
결국 불가능 하기 때문에 구현할 수 없음  
이 방식에 그나마 근접하게 구현한 방식이 LRU, LFU, NUR 등이 있음

#### LRU 페이지 교체 알고리즘  
페이지에 접근한 시간을 기준으로 대상 페이지를 선정함
* 페이지 접근 시간에 기반한 구현
  페이지에 읽기, 쓰기, 실행과 같은 연산이 이루어진 시간을 기준으로 함  
  성능은 FIFO보다 우수하고 최적보다는 조금 떨어짐
* 카운터에 기반한 구현
  카운터를 사용하여 구현
* 참조 비트 시프트 방식
  각 페이지에 일정 크기의 참조 비트를 만들어 사용하는 것

세가지 구현 방식 모두 추가 공간으로 인해 낭비되는 메모리 공간이 많다는 단점이 있음  

#### LFU 페이지 교체 알고리즘  
페이지가 몇 번 사용되었는지를 기준으로 대상 페이지 선정
FIFO보다 성능이 우수하지만  
페이지 접근 횟수를 표시하는 데 사용하는 추가 공간으로 인해  
낭비되는 메모리 공간이 많다는 단점이 있음  

#### NUR 페이지 교체 알고리즘  
불필요한 공간 낭비 문제를 해결한 알고리즘  
추가 비트 2개만 사용하여 미래를 추정  
페이지마다 추가되는 메모리 공간이 항상 2비트  
2비트만 가지고 다른 알고리즘과 유사한 성능을 낼 뿐만 아니라  
쉽게 구현할 수 있기 때문에 가장 많이 사용됨  
FIFO보다 성능이 우수하고 최적과는 거의 비슷함  

#### FIFO 변형 알고리즘  
메모리에 올라온 순서만 고려하고 자주 사용하는 페이지를 고려하지 않음  
성능이 좋지 않아 단점을 개선한 알고리즘으로 2차 기회 페이지 교체 알고리즘과 시계 알고리즘이 있음 

* 2차 기회 페이지 교체 알고리즘  
  큐를 사용하지만 특정 페이지에 접근하여 페이지 부재 없이 성공할 경우  
  해당 페이지를 큐의 맨 뒤로 이동하여 대상 페이지에서 제외함  
  LRU, LFU, NUR 보다는 성능이 낮고 FIFO 보다는 약간 높음  
  큐를 유지하는 비용이 높고, 페이지가 성공하면 작업이 추가된다는 단점이 있음  
* 시계 알고리즘  
  원형 큐를 사용  
  포인터가 시계처럼 한 방향으로 돌게됨  
  대상 포인터와 각 페이지당 참조 비트 하나만 추가하면 되기 때문에  
  NUR보다 추가 공간이 적게 들지만 알고리즘이 복잡하고 계산량이 많다는 단점이 있음

### 03. 스레싱과 프레임 할당
#### 스레싱
하드디스크의 입출력이 너무 많아져서 잦은 페이지 부재로 작업이 멈춘 것 같은 상태  
동시에 실행하는 프로그램의 수를 **멀티프로그래밍 정도**라고 하는데,  
멀티프로그래밍 정도가 너무 높으면 스레싱이 발생함  
메모리가 꽉 차면 CPU가 작업하는 시간보다 스왑 영역으로 페이지를 보내고  
새로운 페이지를 메모리에 가져오는 작업이 빈번해져 CPU가 작업할 수 없는 상태에 이르게 되는데  
이러한 지점을 **스레싱 발생 지점**이라고 함  

남아 있는 프레임을 실행 중인 프로세스에 적절히 나누어주는 정책이 필요
* 정적 할당  
  프로세스 실행 초기에 프레임을 나누어준 후 그 크기를 고정하는것  
  * 균등 할당 방식
    프로세스의 크기와 상관 없이 가능한 프레임을 모든 프로세스에 동일하게 할당하는 방식  
    크기가 큰 프로세스의 경우 필요한 만큼 프레임을 할당받지 못하기 때문에  
    페이지 부재가 빈번하게 발생, 크기가 작은 프로세스의 경우 메모리가 낭비됨
  * 비레 할당 방식
    프로세스의 크기에 비례하여 프레임을 할당하는 방식  
    균등 할당 방식보다는 현실적이지만  
    프로세스가 실행 중에 필요로 하는 프레임을 유동적으로 반영하지 못하는 문제와  
    사용하지 않을 메모리를 처음부터 미리 확보하여 공간을 낭비한다는 문제가 있음  
  

* 동적 할당  
  프로세스를 실행하는 초기에 프레임을 할당하는 방식  
  프로세스를 실행하는 동안 메모리 요구를 반영하지 못한다는 단점이 있음  
  * 작업집합 모델
    지역성 이론을 바탕으로 가장 최근에 접근한 프레임이 이후에도 또 참조될 가능성이 높다는 가정에서 출발  
    최근 일정 시간 동안 참조된 페이지들을 집합으로 만들고, 이 집합에 있는 페이지들을 물리 메모리에 유지하여  
    프로세스의 실행을 도움  
    작업집합 윈도우의 크기에 따라 프로세스의 실행 성능이 달라짐  
  * 페이지 부재 빈도  
    페이지 부재 횟수를 기록하여 페이지 부재 비율을 계산하는 방식  
    페이지 부재 비율의 상한선과 하한선을 설정하여  
    상한선을 초과하면 할당한 프레임이 적은 것이므로 프레임을 추가하여 늘리고  
    하한선 밑으로 내려가면 메모리가 낭비되는 것이므로 할당한 프레임을 회수함  

### 예상 질문
* 페이지 교체 알고리즘이란 무엇인가요?
* 페이지 교체 알고리즘의 순서는 어떻게 되나요?
* 페이지 교체 알고리즘은 어떤 것들이 있나요?
* 캐시의 적중률을 높이기 위해서는 어떻게 해야하나요?
