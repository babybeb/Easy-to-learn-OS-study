# 가상 메모리 관리

## 1. 요구 페이징
<br/>

### [요구 페이징 개요]
 <br/>

 요구 페이징은 프로그램을 실행 할 때, 프로세스를 구성하는 모든 페이지를 메모리에 올리는 것이 아니라 사용자가 요구할 때 메모리로 가져오는 것을 말한다.  
 이를 통해 메모리를 절약하고, 효율적으로 관리할 수 있으며 프로세스 응답 속도 또한 향상시킬 수 있다.    
<br/>


### [페이지 테이블 엔트리의 구조]
 <br/>

![image](https://user-images.githubusercontent.com/107526525/215305365-f98ad4d0-f4b1-4247-b481-dc982f960e23.png)
 
 - 페이지 번호 / 프레임 번호 (= 주소 필드)
 - 접근 비트 (access bit) : 페이지가 메모리에 올라온 후 사용한 적이 있는지 알려주는 비트 
 - 변경 비트 (modified bit) : 페이지가 메모리에 올라온 후 변경한 적이 있었는지 알려주는 비트
 - 유효 비트 (valid bit) : 페이지가 실제 메모리에 있는지 스왑 영역에 있는지 나타내는 비트
 - 읽기(read bit),쓰기(write bit),실행 비트(execute bit) -> 접근 권한 비트(right bit) : 페이지에 대한 권한을 나타내는 비트  
<br/>


### [페이지 부재]
 <br/>

   가상 메모리 페이지 테이블의 유효 비트를 통해 페이지가 물리 메모리에 있는지, 스왑 영역에 있는지 알 수 있다.  
 만약 프로세스가 페이지를 유청했을 때 해당 페이지가 물리 메모리에 없다면 그것을 **페이지 부재**라고 한다.  
 <br/>

   페이지 부재가 발생하면 스왑 영역에 있는 페이지를 물리 메모리의 빈 영역에 올리고 페이지 테이블을 갱신해야 한다.  
 이 때, 메모리에 빈 프레임이 있다면 그것을 활용할 수 있겠지만 빈프레임이 없을 때에는 메모리에 있는 프레임 중 하나를 스왑 영역으로 내보낸 후에야 해당 페이지를 가져올 수 있다.   
   어떤 페이지를 스왑 영역으로 보낼지 결정하는 알고리즘을 **페이지 교체 알고리즘** 이라고 하고 페이지 교체 알고리즘에 의해서 스왑 영역으로 보낼 페이지를 **대상 페이지**라고 한다. 
 <br/>

 ** 세그먼테이션 오류와 페이지 부재의 차이점 : 세그먼테이션 오류는 사용자의 프로세스가 주어진 메모리 공간을 벗어나거나 접근 권한이 없는 곳에 접근해서 발생한다. 반면 페이지 부재는 해당 페이지가 물리 메모리에 없을 때 발생하는 오류로 사용자 프로세스와 무관하다.   
 <br/>


### [지역성]
 <br/>

  메모리가 꽉 차서 어떤 페이지를 소왑 영역으로 보낼 때는 되도록 앞으로 사용하지 않을 페이지를 쫓아내는 것이 좋다. 그렇기 때문에 페이지 교체 알고리즘이 대상 페이지를 찾을 때는 지역성을 바탕으로 한다. 
 <br/>

  - 공간의 지역성 : 현재 위치에서 가까운 데이터에 접근할 확률이 먼 거리에 있는 데이터에 접근할 확률보다 높다.
  - 시간의 지역성 : 현재를 기준으로 가장 가까운 시간에 접근한 데이터가 더 먼 시간에 접근한 데이터보다 사용될 확률이 높다. 
  - 순차적 지역성 : 여러 작업이 순서대로 진행되는 경향이 있다.  
 <br/>

## 2. 페이지 교체 알고리즘
<br/>

### [페이지 교체 알고리즘의 개요]
 <br/> 

  페이지 교체 알고리즘은 페이지 부재 발생 시에 스왑 영역으로 보낼 페이지를 결정하는 알고리즘으로, 메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정하여 페이지 부재를 줄이고 시스템 성능을 향상한다. 
<br/>

### [페이지 교체 알고리즘 종류]
 <br/> 

 - 무작위 페이지 교체 알고리즘 : 특별한 로직 없이 무작위로 대상페이지를 선정하는 방식. 가장 간단하나 성능이 좋지 않아 거의 사용되지 않는다.  
 <br/>

 - FIFO 페이지 교체 알고리즘 : 시간상으로 가장 먼저 들어온 페이지를 대상 페이지로 선정하는 방식. 큐로 쉽게 구현할 수 있고 시간의 지역성을 고려한 알고리즘이지만 무조건 오래된 페이지를 대상 페이지로 선정하기 때문에 성능이 떨어진다.   
  <br/>
 
 - 최적 페이지 교체 알고리즘 : 메모리가 앞으로 사용할 페이지를 미리 살펴보고 페이지 사용 시점까지 가장 멀리 있는 페이지를 대상 페이지로 선정하는 방식. 미래 접근 패턴을 안다는 것이 불가능하여 실제로 구현할 수 없다.   
  <br/>
 
 - LRU 페이지 교체 알고리즘(Least Recently Used) : 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 대상 페이지로 선정하는 방식. 시간을 기록하여 구현할 수도 있고, 카운터나 참조 비트를 이용하는 방법도 있다. 시간 지역성을 고려했지만 접근 시간, 참조 비트를 유지하기 위한 메모리가 추가로 필요하기 때문에 낭비되는 메모리 공간이 많다.   
  <br/>
 
 - LFU 페이지 교체 알고리즘(Least Frequently Used) : 페이지가 사용된 횟수를 기준으로 대상 페이지를 선정하는 방식. LRU와 마찬가지로 횟수 표시하는데에 추가 공간이 필요하므로 메모리가 낭비된다.   
  <br/>
 
 - NUR 페이지 교체 알고리즘(Not Used Recently) : LFU,LRU 와 성능이 거의 비슷하면서도 불필요한 공간 낭비 문제를 해결한 알고리즘이다. 참조 비트, 변경 비트 2개의 비트만 사용하여 참조, 변경 여부를 기록하고 이를 기준으로 하되 참조 비트 -> 변경 비트 순으로 고려하여 대상 페이지를 선정한다. 2bit만 추가하여 다른 알고리즘과 유사한 성능을 내고 쉽게 구현할 수 있기 때문에 가장 많이 사용되는 알고리즘이다.   
  <br/>
 
 - FIFO 변형 알고리즘 
   - 2차 기회 페이지 교체 알고리즘 : FIFO 알고리즘과 마찬가지로 큐를 이용하지만, 특정 페이지에 접근하여 페이지 부재 없이 성공할 경우 해당 페이지를 큐의 맨 뒤로 이동하여 기회를 한 번 더 주는 방식이다. FIFO 보다는 성능이 좋지만 나머지 최적 근접 알고리즘보다 성능이 낮고 페이지가 성공했을 때에 값을 뒤로 이동하는 작업이 추가되는 것이 단점이다.  
    <br/>
  
   - 시계 알고리즘 : 2차 기회 페이지 교체 알고리즘과 유사하지만 원형 큐를 이용하는 방식. 시계 알고리즘에서는 대상 페이지를 가리키는 포인터를 사용하여 포인터가 큐의 맨 바닥으로 내려가면 다시 큐의 처음을 가리키도록 한다. 또한 각 페이지에 참조 비트 하나씩을 추가하여 2차 기회 페이지 교체 알고리즘처럼 기회를 한 번 더 준다. 그러나 대상에서 제외되는 경우는 한 번뿐이다.   
<br/>


## 3. 스레싱과 프레임 할당
<br/>

### [스레싱]
 <br/>  

  프로세스의 수가 늘어남에 따라 한 프로세스가 사용할 수 있는 메모리 공간이 줄어든다. 이에 따라 페이지 교체의 횟수가 계속 늘어나고, cpu자원을 사용하는 시간보다 하드디스크 입출력 시간이 많아져 작업이 멈춘 것 같은 상태를 스레싱이라고 한다. 물리 메모리의 크기를 늘리면 스레싱 발생 시점이 늦춰지기 때문에 컴퓨터 성능이 향상될 수 있다.
 <br/>  

### [프레임 할당]
 <br/>  
  
  스레싱은 각 프로세스에 프레임을 할당하는 문제와도 연관된다. 실행 중인 여러 프로세스에 프레임을 얼마나 나누어주느냐에 따라서 시스템 성능이 달라진다.   어떤 프로세스에는 너무 적은 프레임을 할당하여 페이지 부재가 빈번히 일어나고, 어떤 프로세스에는 너무 많은 프레임을 할당하여 메모리를 낭비할 수 있다.  
따라서 남아있는 프렐임을 실행 중인 프로세스에 적절히 나누어주는 정책이 필요하다. 프로세스에 프레임을 할당하는 방식은 크게 정적할당, 동적 할당이 있다.

 <br/>  

  - 정적할당 : 프로세스 실행 초기에 프레임을 나누어준 후 그 크기를 고정하는 방식
    - 균등 할당 : 프로세스 크기와 상관없이 사용 가능한 프레임을 모든 프로세스에 동일하게 할당한다. 
    - 비례 할당 : 프로세스 크기에 비례하여 프레임을 할당한다. 프로세스가 실행 중에 필요로하는 프레임을 유동적으로 반영하지 못하고, 사용하지 않을 메모리를 처음부터 미리 확보하여 공간을 낭비하는 단점이 있다.  
<br/>

 - 동적 할당 : 시시각각 변하는 요청을 수용하여 프레임을 할당한다. 
   - 작업집합 모델 : 지역성 이론에 근거하여 최근 일정 시간동안 참조된 페이지들을 집합으로 만들고, 이 집합에 있는 페이지들을 물리 메모리에 유지하는 것이다. 작업집합 모델에서는 작업집합 윈도우(작업집합에 포함되는 페이지 범위)가 중요한데 작업집합 윈도우를 너무 크게 잡으면 필요없는 페이지가 메모리에 남아 다른 프로세스에 영향을 미치고 너무 작게 잡으면 필요한 페이지가 스왑 영역으로 옮겨져 프로세스 성능이 떨어진다. 
   - 페이지 부재 빈도 : 페이지 부재 비율을 이용하며 프레임을 할당하는 방식. 페이지 부재 상한선과 하한선을 설정하여 추가적으로 페이지를 할당하거나 회수한다.


---
1. 스레싱의 해결 방안은 ? 