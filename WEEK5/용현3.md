# Demang Paging

## demang paging 이란

메모리 관리자는 언제 페이지를 메모리에 가져올까?

- 사용자(프로세스)가 페이지를 요구할 때 해당 페이지를 메모리로 가져오는 것을 요구 페이징 이라고 한다.
- 사용자가 특정 기능을 요구할 때 해당 모듈을 메모리에 올리면, 모듈을 전부 올리는 것보다 메모리 절약하여 효율적으로 관리할 수 있다.
- 현대의 운영체제에서는 요구 페이징을 기본으로 사용하고 있다.

# Page Fault

### Page 위치 확인

- 가상 메모리의 페이지 테이블 엔트리에는 페이지가 물리 메모리에 있는지, 스왑 영역에 있는지 표시하기 위해 유효비트( `valid/invalid bit` or `present/absent bit`) 를 사용한다
- 유효비트가 1일때는 스왑영역에 존재하는 것이고, 0일때는 물리메모리에 존재한다
    - 유효비트가 1일때는 주소필드(Frame number)에 스왑 영역의 페이지 주소(저장장치 내 주소)가 저장된다.
    - 유효비트가 0일때는 주소필드(Frame number)에 프레임 번호가 저장된다.

### Page Fault

- 참고
    
    [http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-memory-virt-details.html](http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-memory-virt-details.html)
    
    [https://hooni-playground.com/939/](https://hooni-playground.com/939/)
    
    - 페이지 폴트란 프로그램이 자신의 주소 공간에는 존재하지만 시스템의 RAM에는 현재 없는 데이터나 코드에 접근 시도하였을 경우 발생하는 현상을 말합니다.
    - 페이지 폴트가 발생하면 운영 체제는 그 데이터를 메모리로 가져와서 마치 페이지 폴트가 전혀 발생하지 않은 것처럼 프로그램이 계속적으로 작동하게 해줍니다.
        - **Major Page Fault**: 요청한 페이지가 물리 메모리로부터 스왑아웃(Swap-Out)되어 보조기억장치의 가상 메모리에 저장되어있다면 해당 페이지를 다시 물리 메모리로 스왑인(Swap-In)하여야 할 것이다.
        - **Minor Page Fault**: 요청한 페이지가 물리 메모리에는 로드되었지만 메모리 관리 유닛(Memory Management Unit, MMU)에는 로드되어있지 않다고 표시된 경우 이를 Minor 페이지 폴트라 한다.(설명이 좀 복잡하지만, 어느 프로세스의 한 쓰레드가 어떤 페이지를 사용하고 있을 때 해당 프로세스의 다른 쓰레드가 그 페이지를 요청하는 경우를 예시로 들 수 있다.)
    - **물리 메모리에 CPU가 요청한 페이지가 없는것**
- 프로세스가 페이지를 요청했을때, 해당 페이지가 물리 메모리에 없는 상황을 Page Fault라고 한다.
- 페이지 폴트가 발생하면 프로세스는 해당 페이지를 사용할 수 있도록 스왑영역에서 물리 메모리로 옮겨야 한다.
    - 빈 프레임이 존재하면 스왑 영역에서 바로 프레임으로 가져오고,
    - 프레임이 가득 차있으면 메모리에 있는 프레임 중 하나를 스왑 영역으로 내보내고, 해당 페이지를 가져온다.

### 페이지 폴트 동작 과정

![Screenshot 2023-01-29 at 1.37.54 AM.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/be2ade2a-7985-496d-903f-97cd8f8ae937/Screenshot_2023-01-29_at_1.37.54_AM.png)

### 세그먼테이션 오류 VS 페이지 폴트

- 세그먼테이션 오류는 사용자의 프로세스가 주어진 메모리 공간을 벗어나거나 접근 권한이 없는 곳에 접근할 때 발생한다. 즉, 사용자 프로세스에 의해 발생되며 해당 프로세스를 강제 종료하여 해결한다
- 페이지 폴트는 해당 페이지가 물리 메모리에 없을때 발생하는 오류로 사용자 프로세스와 무관한다. 페이지 폴트가 발생하면 MMU는 스왑 영역에서 해당 페이지를 물리 메모리로 옮긴다.

# Page Replacement Algorithm

### 페이지 교체 알고리즘이란

- 페이지 교체 알고리즘은 스왑 영역으로 보낼 페이지(대상 페이지)를 결정하는 알고리즘으로, 메모리 재배치 작업이다.
- 메모리에서 앞으로 사용될 가능성이 적은 페이지를 대상 페이지로 선정하여 페이지 폴트를 줄이고 시스템 성능을 향상시킨다.

아래에서 볼 알고리즘은 `최적 근접 알고리즘`(과거의 데이터를 바탕으로 미래의 접근 패턴을 추정하는 알고리즘) 이다.

## LRU

`Least Recently Used` 페이지 교체 알고리즘

- 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 스왑 영역으로 옮긴다.
- 최근에 사용된 페이지를 놔두고, 오래전에 사용된 페이지를 대상페이지로 선정한다.
- 즉, 페이지에 읽기,쓰기,실행과 같은 연산이 이루어진 시간을 기준으로 한다.

![Screenshot 2023-01-29 at 12.33.59 AM.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0ae61256-fca4-4a44-bad5-d63c4db1ab67/Screenshot_2023-01-29_at_12.33.59_AM.png)

- 위 방법은 페이지 접근 시간을 나타내기 위해 추가적인 비트가 필요하다. 시간이 지날수록 필요한 비트의 수가 늘어날 것이다.
    - 아래와 같이 참조 비트 시프트 방식을 사용하여 비트를 절약할 수 있다.

![Screenshot 2023-01-29 at 12.35.18 AM.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b4150a37-86f3-4827-8711-ef512c032750/Screenshot_2023-01-29_at_12.35.18_AM.png)

- 하지만, 참조 비트 방식도 역시 1바이트를 사용하기 때문에, 적지 않은 공간을 사용한다.

### 단점

- 접근 시간이나 참조 비트를 유지하기 위해 추가 비트를 필요로 하다.

## LFU

`Least Frequently Used` 페이지 교체 알고리즘

- 페이지가 최근에 몇번 사용되었는지를 기준으로 대상 페이지를 선정

![Screenshot 2023-01-29 at 12.38.19 AM.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2414c9f5-e36f-425e-9983-0cb5f1bcb7ab/Screenshot_2023-01-29_at_12.38.19_AM.png)

- 위 경우는 사용 빈도가 같은 경우 맨 위 페이지를 대상으로 페이지를 선정함
- 최근 사용 빈도를 나타내기 위해, 참조 비트 방식을 사용할 수 있다.

### 단점

- 사용 빈도를 나타내기 위해 추가 비트를 필요로 하다.

## LUR

`Least Frequently Used` 페이지 교체 알고리즘

- 페이지가 최근에 몇번 사용되었는지를 기준으로 대상 페이지 선정한다.

![Screenshot 2023-01-29 at 12.41.05 AM.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/af851d71-b891-45ce-9427-05bbb23c4915/Screenshot_2023-01-29_at_12.41.05_AM.png)

- 페이지마다 참조비트,변경 비트를 가지므로 페이지 마다 추가되는 메모리 공간은 2비트뿐이다.
    - 참조비트: 페이지에 접근할 경우(Read/Execute) 1이 됨
    - 변경 비트: 페이지를 변경하면(Write/Append) 1이 됨
- 페이지 교체 시 우선 고려 대상은 참조 비트
    - 참조비트가 0인 페이지를 먼저 찾고, 없으면 변경 비트가 0인 페이지를 찾는다
    - 만약 같은 비트의 페이지가 여러개이면 무작위로 대상 페이지를 선정한다.

LRU,LFU,LUR 페이지 교체 알고리즘의 성능은 거의 비슷하며, FIFO 페이지 교체 알고리즘보다 우수하다. 이 중, 추가되는 메모리 공간이 제일 적은 LUR이 가장 많이 사용된다.

## 페이지 범위

전역 페이지 교체: 전체 프레임을 대상으로 하는 교체 알고리즘

지역 페이지 교체: 현재 실행중인 프로세스의 프레임을 대상으로 교체 알고리즘 적용

![Screenshot 2023-01-29 at 1.51.23 AM.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f4d43242-359f-4894-98bb-6d090d5b94b3/Screenshot_2023-01-29_at_1.51.23_AM.png)

- 지역 페이지 교체 장점
    - 전체 프로세스에 할당된 프레임의 수가 변하지 않아 스레싱을 줄일 수 있다.
    - 만약 페이지 교체를 위해 다른 프로세스에 할당된 프레임을 빼앗으면 프레임을 빼앗긴 프로세스는 스레싱 발생 지점에 도달할 수 있기 때문이다.
- 지역 페이지 교체 단점
    - 전체 프레임에서 사용 빈도가 높은 프레임에도 불구하고 페이지 교체가 될 수 있다
    - 자주 사용하는 페이지가 교체되면 스레싱에 빠질 수 있다.

**전체 시스템 입장에서는 전역 교체 방식이 지역 교체 방식보다 효율적이다.**

# Thrashing
### 스레싱이란

- 작은 페이징과 페이지 폴트가 발생하여 프로세스 실행 작업보다 페이지 교체 작업이 빈번해져서 프로세스 실행 시간보다 페이지 교체 시간이 많은 상태
    - 스레싱이 되는 시점을 스레싱 발생 시점이라고 한다.

![Screenshot 2023-01-29 at 12.47.12 AM.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9546af13-6ab1-4166-848d-1f0ee88df67f/Screenshot_2023-01-29_at_12.47.12_AM.png)

- **스레싱을 근본적으로 줄이기 위해 다중 프로그래밍 정도를 낮추어야 한다.**

### 스레싱 발생 과정

![[참고 사이트](http://blog.skby.net/%EC%8A%A4%EB%A0%88%EC%8B%B1-thrashing/)](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2fddb7fd-627e-4e79-88d7-6ace93e86c1f/Screenshot_2023-01-29_at_12.50.41_AM.png)

[참고 사이트](http://blog.skby.net/%EC%8A%A4%EB%A0%88%EC%8B%B1-thrashing/)

### 스레싱 해결
- 스레싱을 해결하려면 근본적으로는 실행하고 있는 프로세스를 줄이거나, 메모리 양을 늘리면 된다.
- 하지만, 실행해야 하는 프로세스를 종료할 수 없기에 프로세스에 프레임을 할당하는 방식을 고려해야 한다.
- 프로세스에 프레임을 할당하는 방식은 크게 정적할당과 동적할당으로 구분된다.

### 정적 프레임 할당

- 균등할당
    - **프로세스의 크기와 상관없이 사용 가능한 모든 프레임을 모든 프로세스에 동일하게 할당하는 방식**
        - 크기가 큰 프로세스의 경우 페이지 폴트가 빈번하게 발생한다.
        - 크기가 작은 프로세스의 경우, 사용하지 않는 프레임이 발생하여 메모리 낭비가 발생한다.
- 비례할당
    - **프로세스의 크기와 비례하여 프레임을 할당하는 방식**
        - 프로세스가 실행중에 필요로 하는 프레임을 유동적으로 반영하지 못함
        - 사용하지 않는 메모리를 처음부터 미리 할당하여 공간 방비
    

### 동적 프레임 할당 - 작업집합 모델

- 지역성 이론을 바탕으로 하여, 가장 최근에 접근한 프레임이 이후에도 또 참조될 가능성이 높다는 가정에서 출발한다.
- 최근 일정 시간동안 참조된 페이지들을 집합으로 만들고, 이 집합에 있는 페이지들을 물리 메모리에 유지하며 프로세스의 실행을 돕는다
    - 작업집합에 포함되는 페이지의 범위를 작업집합 윈도우라고 한다.
- 작업집합 윈도우에는 현재시점부터 시간적으로 가까운 페이지부터 삽입된다.
- 작업집합 크기가 5라는 것은 페이지에 다섯번 접근할때마다 작업집합을 갱신한다는 것이다.

![Screenshot 2023-01-29 at 1.23.07 AM.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/315ff2a4-62f8-4973-b469-e1dd8db21856/Screenshot_2023-01-29_at_1.23.07_AM.png)

- 작업집합 윈도우를 너무 크게 잡으면, 필요없는 페이지가 메모리를 차지한다.
- 너무 작게 잡으면, 필요한 페이지가 스왑영역으로 옮겨진다.

→ **작업집합 모델은 프로세스의 성능은 높이지만 스레싱 문제를 해결하지 못한다.**

![[http://blog.skby.net/스레싱-thrashing/](http://blog.skby.net/%EC%8A%A4%EB%A0%88%EC%8B%B1-thrashing/)](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ff40ee57-686d-438b-944b-cb68785b7132/Screenshot_2023-01-29_at_1.24.36_AM.png)

[http://blog.skby.net/스레싱-thrashing/](http://blog.skby.net/%EC%8A%A4%EB%A0%88%EC%8B%B1-thrashing/)

### 동적 프레임 할당 - 페이지 부재 빈도

- 프로세스의 페이지 폴트 비율의 상한선과 하한선을 설정하는 방식
- 페이지 폴트 비율이 상한선을 초과하면 프레임을 추가할당한다
- 하한선 밑으로 내려가면 할당한 프레임을 회수한다

![[http://blog.skby.net/스레싱-thrashing/](http://blog.skby.net/%EC%8A%A4%EB%A0%88%EC%8B%B1-thrashing/)](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/495dde63-28ef-4a04-87e7-654813a5aed9/Screenshot_2023-01-29_at_1.26.21_AM.png)

[http://blog.skby.net/스레싱-thrashing/](http://blog.skby.net/%EC%8A%A4%EB%A0%88%EC%8B%B1-thrashing/)

- 프로세스가 실행되면서 추가적으로 페이지를 할당하거나 회수하여 적정 페이지 할당량을 조절한다.

![Screenshot 2023-01-29 at 1.27.41 AM.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/db5cfe99-4389-4d9a-b698-b6135c3f1096/Screenshot_2023-01-29_at_1.27.41_AM.png)

### 효과적인 스레싱 발생 최소화 예방 기법
- 운영체제: 사용할 수 있는 메모리 공간을 늘리는 것이다.
- 프로그램: 지역성 고려, 입출력 방지하여 요구 페이징 횟수를 줄이는 것이다.